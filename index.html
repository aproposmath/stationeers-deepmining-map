<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Stationeers Maps</title>
  <link rel="icon" type="image/webp" href="icon.webp">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <style>
    body {
      font-family: sans-serif;
    }

    svg {
      border: 0px solid #ccc;
    }

    path {
      stroke: #333;
      stroke-width: 0.5px;
      cursor: pointer;
    }

    text {
      font-size: 10px;
      fill: #111;
      pointer-events: none;
    }

    .tooltip {
      position: absolute;
      background: lightgray;
      padding: 5px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
    }
  </style>
</head>

<body>
  <div id="fileButtons" style="margin: 10px; width: 800px;">

    <div style="margin: 10px; display: flex; gap: 10px;">
      <div id="planetButtons">
        <button data-file="lunar">Lunar</button>
        <button data-file="europa">Europa</button>
        <button data-file="mars">Mars</button>
        <button data-file="mimas">Mimas</button>
        <button data-file="venus">Venus</button>
        <button data-file="vulcan">Vulcan</button>
      </div>

      <div id="regionTypeButtons" style="margin-left: auto; display: flex; gap: 10px;">
        <button data-region="mining">Mining</button>
        <button data-region="names">Names</button>
        <button data-region="poi">POI</button>
      </div>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <div style="display: flex;">
    <div style="flex: 1; padding: 10px; border: 0px solid #ccc;">
      <svg width="800" height="800"></svg>
    </div>
    <div style="flex: 1; padding: 10px; border: 0px solid #ccc;">
      <label style="display: block; margin-top: 10px;">
        <input type="checkbox" id="toggleTerrain" checked> Terrain
      </label>
      <label style="display: block;">
        <input type="checkbox" id="toggleSpawn"> Start Locations
      </label>
      <label style="display: block;">
        <input type="checkbox" id="toggleNorth"> North Up
      </label>
      <label style="display: block; margin-top: 20px; margin-bottom: 5px;">Regions</label>
      <div id="colorFilter"></div>
    </div>
  </div>

  <script>
    function getSettingsFromUI() {
      const transform = d3.zoomTransform(svg.node());
      const checkBoxes = colorFilter.selectAll("input[type=checkbox]").nodes();
      selectedRegions = [];
      for (const i in checkBoxes) {
        if (checkBoxes[i].checked)
          selectedRegions.push(+i);
      }
      const settings = {
        planet: currentPlanet,
        region: currentRegionType,
        terrain: document.getElementById('toggleTerrain').checked ? '1' : '0',
        spawn: document.getElementById('toggleSpawn').checked ? '1' : '0',
        zoom: transform.k.toFixed(2),
        x: Math.round(transform.x),
        y: Math.round(transform.y),
        selected: selectedRegions === null ? "" : selectedRegions.join('-'),
        rotate: northUp ? '1' : '0',
      };

      const query = new URLSearchParams(settings).toString();
      window.history.replaceState(null, '', '?' + query);
    }

    function applySettingsFromQuery(params) {
      const terrain = params.get('terrain');
      if (terrain !== null) {
        document.getElementById('toggleTerrain').checked = terrain === '1';
      }

      const spawn = params.get('spawn');
      if (spawn !== null) {
        document.getElementById('toggleSpawn').checked = spawn === '1';
      }
      const scale = parseFloat(params.get('zoom'));
      const x = parseFloat(params.get('x'));
      const y = parseFloat(params.get('y'));

      if (!isNaN(scale) && !isNaN(x) && !isNaN(y)) {
        svg.call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
      }
      selectedRegions = params.get('selected');
      if(selectedRegions === null)
        selectedRegions = [0];
      else
        selectedRegions = selectedRegions.split('-').map(s => parseInt(s));
      northUp = params.get("rotate") === '1';
      document.getElementById('toggleNorth').checked = northUp ? true : false;
    }


    const svg = d3.select("svg");
    const width = +svg.attr("width");
    const height = +svg.attr("height");
    const tooltip = d3.select("#tooltip");

    const colorFilter = d3.select("#colorFilter");

    let allData = {};

    const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on("zoom", (event) => {
        for (var group of ["mining", "names", "poi", "spawn", "imageGroup"]) {
          svg.select("." + group).attr("transform", event.transform);
        }
        // svg.selectAll("g").attr("transform", event.transform);
        getSettingsFromUI();
      });

    const params = new URLSearchParams(window.location.search);
    let currentPlanet = params.get('planet') || 'lunar';
    let currentRegionType = params.get('region') || 'mining';
    let selectedRegions = [0];
    let northUp = false;
    applySettingsFromQuery(params);
    let mapWidth = 4000;
    let mapHeight = 4000;

    let updateRender = () => { };
    let render = () => { };

    loadMap(currentPlanet, currentRegionType);

    async function loadData(planet) {

      const raw = await d3.json(`data/${planet}.json`);
      const data = {};

      for (const key in raw) {
        if (['mining', 'names', 'poi'].includes(key)) {
          data[key] = topojson.feature(raw[key], raw[key].objects.data);
        }
        else {
          data[key] = raw[key];
        }
      }
      if (northUp) {
        for (const key of ['mining', 'names', 'poi']) {
          data[key].features.forEach(f => {
            f.geometry.coordinates = f.geometry.coordinates.map(polygon => {
              return polygon.map(([x, y]) => ([-x, -y]));
            });
          });
        }
      }
      return data;


      const get = async (name) => {
        const data = await d3.json(`data/${planet}_${name}.topojson`)
        const topoData = topojson.feature(data, data.objects.data);
        return topoData;
      }

      return {
        mining: await get("mining"),
        names: await get("names"),
        poi: await get("poi"),
      }
    }

    async function loadMap(planet, regionType) {
      currentPlanet = planet;
      currentRegionType = regionType;

      for (var group of ["mining", "names", "poi", "spawn"]) {
        svg.select("." + group).remove();
      }

      const allData = await loadData(planet);
      const geojson = allData.mining;

      // Helper to get selected colors (excluding 'all')
      function getSelectedColors() {
        const checked = colorFilter.selectAll("input[type=checkbox]:checked").nodes();
        const values = checked.map(input => input.value);
        if (values.includes("all")) return true;
        return new Set(values);
      }


      const projection = d3.geoIdentity().reflectY(true).fitSize([width, height], geojson);
      const path = d3.geoPath().projection(projection);
      svg.selectAll("g").remove();
      const g = svg.append("g").attr("class", "imageGroup");
      const currentTransform = d3.zoomTransform(svg.node());
      g.attr("transform", currentTransform)
      const imgTransform = northUp ? `rotate(180, ${width / 2}, ${height / 2})` : "";
      const invertFilter = northUp ? "invert(1)" : "none";
      const terrainImage = g.append("image")
        .attr("class", "terrainImage")
        .attr("href", `data/${planet}_terrain.webp`)
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", height)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .attr("opacity", 1.0)
        .attr("transform", imgTransform)
        // .attr("filter", invertFilter);
        .style("filter", invertFilter);
      ;

      const hideTooltip = () => {tooltip.style("opacity", 0.0)};
      svg.on("mouseleave", hideTooltip)

      svg.on("mousemove", function (event) {
        // Get mouse position in screen coords
        const [mouseX, mouseY] = d3.pointer(event);

        // Use the inverse of the current zoom transform to map back to SVG coords
        const transform = d3.zoomTransform(svg.node());
        const svgX = (mouseX - transform.x) / transform.k;
        const svgY = (mouseY - transform.y) / transform.k;

        let x = Math.round((svgX / 800 - 0.5) * mapWidth);
        let y = Math.round((0.5 - svgY / 800) * mapHeight);
        if (northUp) {
          x = -x;
          y = -y;
        }

        tooltip
          .style("opacity", 1)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 20) + "px")
          .html(`
              <strong>X:</strong> ${x} <br/>
              <strong>Y:</strong> ${y} <br/>`);
      });

      function addCompass() {
        svg.selectAll(".compass").remove();
        const size = 60;
        const w2 = 10;

        const compass = svg.append("g")
          .attr("class", "compass")

        const arrow = compass.append("g")
          .attr("class", "compass-arrow")

        const x0 = -w2;
        const x1 = w2;
        let y0 = 0;
        let y1 = -size;
        let textPos = 20;

        if (northUp) {
          y0 = -size;
          y1 = 0;
          textPos = - size - 10;
        }

        arrow.append("path")
          .attr("d", d3.line()([[0, y0], [x0, y1], [x1, y1], [0, y0]]))
          .attr("fill", "red");

        compass.append("text")
          .attr("y", textPos)
          .attr("text-anchor", "middle")
          .text("N")
          .style("font-size", "20px")
          .style("fill", "red")
          .style("stroke", "black")
          .style("stroke-width", "2px")
          .style("paint-order", "stroke")
      }

      function renderRegions(regionType, opacity, selectedColors) {
        addCompass()
        svg.select("." + regionType).remove();
        const g = svg.append("g").attr("class", regionType);
        const currentTransform = d3.zoomTransform(svg.node());
        g.attr("transform", currentTransform);
        const data = allData[regionType];

        const allFeatures = data.features;

        const isVisible = (d) => {
          if (selectedColors === undefined) return true;
          if (selectedColors === true) return true;
          const col = d.properties.color_hex;
          if (col === undefined) return true;
          return selectedColors.has(col);
        };

        const regions = g.selectAll("path")
          .data(allFeatures)
          .enter()
          .append("path")
          .attr("d", path)
          .style("opacity", opacity)
          .attr("fill", d => {
            const c = d.properties.color_hex || "transparent";
            return isVisible(d) ? c : "transparent";
          })
          .style("mix-blend-mode", "multiply")
          ;
        g.selectAll("text")
          .data(allFeatures)
          .enter()
          .append("text")
          .style("font-size", "14px")
          .style("fill", "white")
          .style("stroke", "black")
          .style("stroke-width", "2px")
          .style("paint-order", "stroke")
          .attr("transform", d => {
            const centroid = path.centroid(d);
            return `translate(${centroid[0]}, ${centroid[1]})`;
          })
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .each(function (d) {
            if (isVisible(d) === false) return;
            const textEl = d3.select(this);
            const lines = d.properties.name?.split(" ") || [];
            const lineHeightEm = 1.2;
            const offset = -((lines.length - 1) / 2) * lineHeightEm;

            lines.forEach((line, i) => {
              textEl.append("tspan")
                .attr("x", 0)
                .attr("dy", (i === 0 ? offset : lineHeightEm) + "em")
                .text(line);
            });
          });

      }

      render = () => {
        getSettingsFromUI();
        const showTerrain = document.getElementById("toggleTerrain").checked;
        const showSpawn = document.getElementById("toggleSpawn").checked;

        svg.select(".terrainImage").attr("visibility", showTerrain ? "visible" : "hidden");

        zoom.on("start", hideTooltip)

        const regionType = currentRegionType;
        svg.select(".mining").remove();
        svg.select(".names").remove();
        svg.select(".poi").remove();
        svg.select(".spawn").remove();
        const opacity = showTerrain || showSpawn ? 0.7 : 1.0;

        const selectedColors = getSelectedColors();
        renderRegions(regionType, opacity, selectedColors);

        const spawn = svg.append("g").attr("class", "spawn");
        spawn.attr("visibility", showSpawn ? "visible" : "hidden");
        const currentTransform = d3.zoomTransform(svg.node());
        spawn.attr("transform", currentTransform);

        Object.entries(allData.start_locations).forEach(([name, coords]) => {
          let px = coords[0] / mapWidth + 0.5;
          let py = 1.0 - (coords[1] / mapHeight + 0.5);
          if (northUp) {
            px = 1 - px;
            py = 1 - py;
          }
          const [x,y] = [width * px, height * py]

          spawn.append("circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 5)
            .attr("fill", "red")
            .attr("stroke", "black")
            .attr("stroke-width", 1);

          spawn.append("text")
            .attr("x", x + 7)
            .attr("y", y - 7)
            .text(name)
            .style("font-size", "14px")
            .style("fill", "white")
            .style("stroke", "black")
            .style("stroke-width", "2px")
            .style("paint-order", "stroke")
        });

        const svgWidth = +svg.attr("width");
        const svgHeight = +svg.attr("height");
        const compass = svg.select(".compass");
        compass.raise();
        compass.attr("transform", `translate(${width - 30}, ${height - 40})`);
      }

      svg.call(zoom);

      updateRender = () => {
        colorFilter.selectAll("*").remove(); // clear filters
        const data = allData[currentRegionType].features;

        const uniqueColors = Array.from(new Set(data.map(f => f.properties.color_hex)))
          .filter(c => c); // remove undefined

        const color2Name = {};

        data.forEach(f => {
          if (f.properties.color_hex)
            color2Name[f.properties.color_hex] = f.properties.name;
        });

        // Add "All" checkbox for convenience
        colorFilter.append("label")
          .html(`<input type="checkbox" value="all"> All`)
          .style("margin-right", "10px")
          .style("display", "block")
          ;

        uniqueColors.forEach(color => {
          colorFilter.append("label")
            .html(`<input type="checkbox" value="${color}"> <span style="color:${color}">${color2Name[color]}</span>`)
            .style("display", "block")
            .style("margin-right", "10px");
        });
        for (const i in colorFilter.selectAll("input[type=checkbox]").nodes())
          if (selectedRegions.includes(parseInt(i)))
            colorFilter.selectAll("input[type=checkbox]").nodes()[i].checked = true;

        colorFilter.selectAll("input[type=checkbox]").on("change", function () {
          if (this.value === "all") {
            if (this.checked) {
              colorFilter.selectAll("input[type=checkbox]").property("checked", false);
              this.checked = true;
            }
          } else {
            if (this.checked) {
              colorFilter.select("input[value=all]").property("checked", false);
            }
            // If none checked, check "All"
            if (colorFilter.selectAll("input[type=checkbox]:checked").nodes().length === 0) {
              colorFilter.select("input[value=all]").property("checked", true);
            }
          }
          render();
        });

        render();
      }

      updateRender();
    }

    d3.selectAll("#planetButtons button").on("click", function () {
      const planet = d3.select(this).attr("data-file");
      svg.call(zoom.transform, d3.zoomIdentity);
      selectedRegions = [0];
      loadMap(planet, currentRegionType);
    });

    d3.selectAll("#regionTypeButtons button").on("click", function () {
      selectedRegions = [0];
      currentRegionType = d3.select(this).attr("data-region");
      updateRender();
    });
    d3.select("#toggleTerrain").on("change", () => {render();});
    d3.select("#toggleSpawn").on("change", () => {render();});
    d3.select("#toggleNorth").on("change", () => {
      northUp = d3.select("#toggleNorth").property("checked");
      loadMap(currentPlanet, currentRegionType);
    });

  </script>
</body>

</html>
