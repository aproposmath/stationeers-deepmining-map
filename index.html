<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Stationeers Maps</title>
  <link rel="icon" type="image/webp" href="icon_transparent.webp">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson-client@3"></script>
  <style>
    body {
      font-family: sans-serif;
    }

    svg {
      border: 0px solid #ccc;
    }

    path {
      stroke: #333;
      stroke-width: 0.5px;
      cursor: pointer;
    }

    text {
      font-size: 10px;
      fill: #111;
      pointer-events: none;
    }

    .tooltip {
      position: absolute;
      background: lightgray;
      padding: 5px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
    }
  </style>
</head>

<body>
  <div id="fileButtons">
    <div id="buttonsHeader" style="display: inline-block;">

      <div style="margin: 10px; display: flex; gap: 10px;">
        <div id="planetButtons">
          <button data-file="lunar">Lunar</button>
          <button data-file="europa">Europa</button>
          <button data-file="mars">Mars</button>
          <button data-file="mimas">Mimas</button>
          <button data-file="venus">Venus</button>
          <button data-file="vulcan">Vulcan</button>
        </div>

        <div id="regionTypeButtons" style="margin-left: auto; display: flex; gap: 10px;">
          <button data-region="mining">Mining</button>
          <button data-region="names">Names</button>
          <button data-region="poi">POI</button>
        </div>
      </div>
    </div>
    <div style="margin-left: auto; display: inline-block; margin-left: 20px; gap: 10px;">
      <button id="share" title="Share view"
        style="height: 40px; width: 40px; vertical-align: middle; display: inline-flex; align-items: center; justify-content: center;">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"
          viewBox="0 0 512 512"><!--!Font Awesome Free v7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M384 192c53 0 96-43 96-96s-43-96-96-96-96 43-96 96c0 5.4 .5 10.8 1.3 16L159.6 184.1c-16.9-15-39.2-24.1-63.6-24.1-53 0-96 43-96 96s43 96 96 96c24.4 0 46.6-9.1 63.6-24.1L289.3 400c-.9 5.2-1.3 10.5-1.3 16 0 53 43 96 96 96s96-43 96-96-43-96-96-96c-24.4 0-46.6 9.1-63.6 24.1L190.7 272c.9-5.2 1.3-10.5 1.3-16s-.5-10.8-1.3-16l129.7-72.1c16.9 15 39.2 24.1 63.6 24.1z" />
        </svg>
      </button>
    </div>
  </div>

  <div id="root" style="display: flex; align-items: flex-start;">
    <div id="canvasContainer" style="position: relative;">
      <svg id="svg" style="position: absolute; top: 0; left: 0;"></svg>
      <div id="iconLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
      </div>
    </div>

    <div id="sidePane" style="margin-left: 20px;">
      <label style="display: block; margin-top: 10px;">
        <input type="checkbox" id="toggleTerrain" checked> Terrain
      </label>
      <label style="display: block;">
        <input type="checkbox" id="toggleSpawn"> Start Locations
      </label>
      <label style="display: block;">
        <input type="checkbox" id="toggleNorth"> North Up
      </label>

      <label style="display: block; margin-top: 20px; margin-bottom: 5px;">Regions</label>
      <div id="colorFilter"></div>
    </div>

    <div class="tooltip" id="tooltip"></div>

  </div>
  <script>
    const AUTOLATHE_ICON_URL = "https://stationeers-wiki.com/images/8/85/StructureAutolathe_BuildState4.png"
    const PLAYER_ICON_URL = "icon_transparent.webp"

    function setCanvasSize(width, height) {
      console.log("Setting canvas size:", width, height);
      canvasWidth = width;
      canvasHeight = height;

      const container = document.getElementById("canvasContainer");
      const svg = document.getElementById("svg");

      if (container && svg) {
        container.style.width = `${width}px`;
        container.style.height = `${height}px`;
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
      }

      // Update other related elements if needed
      const iconLayer = document.getElementById("iconLayer");
      if (iconLayer) {
        iconLayer.style.width = `${width}px`;
        iconLayer.style.height = `${height}px`;
      }

      const buttonsHeader = document.getElementById("buttonsHeader");
      if (buttonsHeader) {
        buttonsHeader.style.width = `${width}px`;
      }
    }

    // setCanvasSize(800, 800);

    function getSettingsFromUI() {
      const transform = d3.zoomTransform(svg.node());
      const checkBoxes = colorFilter.selectAll("input[type=checkbox]").nodes();
      selectedRegions = [];
      for (const i in checkBoxes) {
        if (checkBoxes[i].checked)
          selectedRegions.push(+i);
      }
      const settings = {
        planet: currentPlanet,
        region: currentRegionType,
        terrain: document.getElementById('toggleTerrain').checked ? '1' : '0',
        spawn: document.getElementById('toggleSpawn').checked ? '1' : '0',
        zoom: transform.k.toFixed(2),
        x: Math.round(transform.x),
        y: Math.round(transform.y),
        selected: selectedRegions === null ? "" : selectedRegions.join('-'),
        rotate: northUp ? '1' : '0',
      };

      if (iconsData.length > 0) {
        settings.icons = encodeURIComponent(JSON.stringify(iconsData));
      }

      const query = new URLSearchParams(settings).toString();
      // window.history.replaceState(null, '', '?' + query);
      navigator.clipboard.writeText(window.location.origin + window.location.pathname + '?' + query);
      alert("Link copied to clipboard!");
    }

    function applySettingsFromQuery(params) {
      const terrain = params.get('terrain');
      if (terrain !== null) {
        document.getElementById('toggleTerrain').checked = terrain === '1';
      }

      const spawn = params.get('spawn');
      if (spawn !== null) {
        document.getElementById('toggleSpawn').checked = spawn === '1';
      }
      const scale = parseFloat(params.get('zoom'));
      const x = parseFloat(params.get('x'));
      const y = parseFloat(params.get('y'));

      if (!isNaN(scale) && !isNaN(x) && !isNaN(y)) {
        svg.call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
      }
      selectedRegions = params.get('selected');
      if (selectedRegions === null)
        selectedRegions = [0];
      else
        selectedRegions = selectedRegions.split('-').map(s => parseInt(s));
      northUp = params.get("rotate") === '1';
      document.getElementById('toggleNorth').checked = northUp ? true : false;

      isEmbed = params.get('embed') === '1';
      if (isEmbed) {
        document.getElementById('fileButtons').style.display = 'none';
        document.getElementById('sidePane').style.display = 'none';
        const root = document.getElementById('root');
        root.style.margin = '0px';
        root.style.width = `${canvasWidth}px`;
        root.style.height = `${canvasHeight}px`;
        root.style.padding = '0px';
        root.style.boxShadow = 'none';
        document.body.style.background = 'none';
        document.body.style.overflow = 'hidden';
      }

      const icons = params.get('icons');
      if (icons !== null) {
        try {
          iconsData = JSON.parse(decodeURIComponent(icons));
        } catch (e) {
          console.error("Failed to parse icons from URL:", e);
          iconsData = [];
        }
      }
    }

    function updateIconPositions() {
      const transform = d3.zoomTransform(svg.node());
      const iconLayer = d3.select("#iconLayer");
      iconLayer.selectAll("img").each(function () {
        const img = d3.select(this);
        let dataX = +img.attr("data-x");
        let dataY = +img.attr("data-y");

        if (northUp) {
          dataX = - dataX;
          dataY = - dataY;
        }

        dataX = (dataX + 0.5) * canvasWidth;
        dataY = (dataY + 0.5) * canvasHeight;

        const screenX = transform.applyX(dataX);
        const screenY = transform.applyY(dataY);

        img.style("left", `${screenX}px`)
          .style("top", `${screenY}px`);

        const isVisible = screenX >= 0 && screenX <= canvasWidth && screenY >= 0 && screenY <= canvasHeight;
        img.style("display", isVisible ? "block" : "none");
      });
    }

    function addIcons() {
      const iconLayer = d3.select("#iconLayer");
      iconLayer.selectAll("img").remove(); // clean up

      for (const icon of iconsData) {
        let url = "";
        if (icon.type === "player") {
          url = PLAYER_ICON_URL;
        }
        else if (icon.type === "autolathe") {
          url = AUTOLATHE_ICON_URL;
        }

        const size = icon.size || 32;
        const img = iconLayer.append("img")
          .attr("src", url)
          .style("position", "absolute")
          .style("width", `${size}px`)
          .style("height", `${size}px`)
          .style("transform", "translate(-16px, -16px)") // center on position
          .attr("data-x", icon.position[0] / mapWidth)
          .attr("data-y", -icon.position[2] / mapHeight);
      }
      updateIconPositions();
    }



    const svg = d3.select("#svg");
    const tooltip = d3.select("#tooltip");

    const colorFilter = d3.select("#colorFilter");

    let isEmbed = false;
    let allData = {};
    let iconsData = [];
    const params = new URLSearchParams(window.location.search);
    let canvasWidth = -1;
    let canvasHeight = -1;
    setCanvasSize(parseInt(params.get('width') || '800'), parseInt(params.get('height') || '800'));
    const width = +svg.attr("width");
    const height = +svg.attr("height");
    let currentPlanet = params.get('planet') || 'lunar';
    let currentRegionType = params.get('region') || 'mining';
    let selectedRegions = [0];
    let northUp = false;
    let mapWidth = 4000;
    let mapHeight = 4000;

    let updateRender = () => { };
    let render = () => { };

    const zoom = d3.zoom()
      .scaleExtent([1, 100])
      .on("zoom", (event) => {
        const t = event.transform;
        for (var group of ["mining", "names", "poi", "spawn", "imageGroup"]) {
          svg.select("." + group).attr("transform", t);
        }
        updateIconPositions();
      });
    applySettingsFromQuery(params);

    loadMap(currentPlanet, currentRegionType);

    async function loadData(planet) {

      const raw = await d3.json(`data/${planet}.json`);
      const data = {};

      for (const key in raw) {
        if (['mining', 'names', 'poi'].includes(key)) {
          data[key] = topojson.feature(raw[key], raw[key].objects.data);
        }
        else {
          data[key] = raw[key];
        }
      }
      if (northUp) {
        for (const key of ['mining', 'names', 'poi']) {
          data[key].features.forEach(f => {
            f.geometry.coordinates = f.geometry.coordinates.map(polygon => {
              return polygon.map(([x, y]) => ([-x, -y]));
            });
          });
        }
      }

      return data;
    }

    async function loadMap(planet, regionType) {
      currentPlanet = planet;
      currentRegionType = regionType;

      for (var group of ["mining", "names", "poi", "spawn"]) {
        svg.select("." + group).remove();
      }

      allData = await loadData(planet);
      const geojson = allData.mining;

      // Helper to get selected colors (excluding 'all')
      function getSelectedColors() {
        const checked = colorFilter.selectAll("input[type=checkbox]:checked").nodes();
        const values = checked.map(input => input.value);
        if (values.includes("all")) return true;
        return new Set(values);
      }


      const projection = d3.geoIdentity().reflectY(true).fitSize([width, height], geojson);
      const path = d3.geoPath().projection(projection);
      svg.selectAll("g").remove();
      const g = svg.append("g").attr("class", "imageGroup");
      const currentTransform = d3.zoomTransform(svg.node());
      g.attr("transform", currentTransform)
      const imgTransform = northUp ? `rotate(180, ${width / 2}, ${height / 2})` : "";
      const invertFilter = northUp ? "invert(1)" : "none";
      const terrainImage = g.append("image")
        .attr("class", "terrainImage")
        .attr("href", `data/${planet}_terrain.webp`)
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", height)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .attr("opacity", 1.0)
        .attr("transform", imgTransform)
        // .attr("filter", invertFilter);
        .style("filter", invertFilter);
      ;

      const hideTooltip = () => {tooltip.style("opacity", 0.0)};
      svg.on("mouseleave", hideTooltip)

      svg.on("mousemove", function (event) {
        // Get mouse position in screen coords
        const [mouseX, mouseY] = d3.pointer(event);

        // Use the inverse of the current zoom transform to map back to SVG coords
        const transform = d3.zoomTransform(svg.node());
        const svgX = (mouseX - transform.x) / transform.k;
        const svgY = (mouseY - transform.y) / transform.k;

        let x = Math.round((svgX / canvasHeight - 0.5) * mapWidth);
        let y = Math.round((0.5 - svgY / canvasHeight) * mapHeight);
        if (northUp) {
          x = -x;
          y = -y;
        }

        if (x < -mapWidth / 2 || x > mapWidth / 2 || y < -mapHeight / 2 || y > mapHeight / 2) {
          hideTooltip();
          return;
        }

        tooltip
          .style("opacity", 1)
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY + 20) + "px")
          .html(`
              <strong>X:</strong> ${x} <br/>
              <strong>Y:</strong> ${y} <br/>`);
      });

      function addCompass() {
        svg.selectAll(".compass").remove();
        const size = 60;
        const w2 = 10;

        const compass = svg.append("g")
          .attr("class", "compass")

        const arrow = compass.append("g")
          .attr("class", "compass-arrow")

        const x0 = -w2;
        const x1 = w2;
        let y0 = 0;
        let y1 = -size;
        let textPos = 20;

        if (northUp) {
          y0 = -size;
          y1 = 0;
          textPos = - size - 10;
        }

        arrow.append("path")
          .attr("d", d3.line()([[0, y0], [x0, y1], [x1, y1], [0, y0]]))
          .attr("fill", "red");

        compass.append("text")
          .attr("y", textPos)
          .attr("text-anchor", "middle")
          .text("N")
          .style("font-size", "20px")
          .style("fill", "red")
          .style("stroke", "black")
          .style("stroke-width", "2px")
          .style("paint-order", "stroke")
      }

      function renderRegions(regionType, opacity, selectedColors) {
        addCompass();
        svg.select("." + regionType).remove();
        const g = svg.append("g").attr("class", regionType);
        const currentTransform = d3.zoomTransform(svg.node());
        g.attr("transform", currentTransform);
        const data = allData[regionType];

        const allFeatures = data.features;

        const isVisible = (d) => {
          if (selectedColors === undefined) return true;
          if (selectedColors === true) return true;
          const col = d.properties.color_hex;
          if (col === undefined) return true;
          return selectedColors.has(col);
        };

        const regions = g.selectAll("path")
          .data(allFeatures)
          .enter()
          .append("path")
          .attr("d", path)
          .style("opacity", opacity)
          .attr("fill", d => {
            const c = d.properties.color_hex || "transparent";
            return isVisible(d) ? c : "transparent";
          })
          .style("mix-blend-mode", "multiply")
          ;
        g.selectAll("text")
          .data(allFeatures)
          .enter()
          .append("text")
          .style("font-size", "14px")
          .style("fill", "white")
          .style("stroke", "black")
          .style("stroke-width", "2px")
          .style("paint-order", "stroke")
          .attr("transform", d => {
            const centroid = path.centroid(d);
            return `translate(${centroid[0]}, ${centroid[1]})`;
          })
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "middle")
          .each(function (d) {
            if (isVisible(d) === false) return;
            const textEl = d3.select(this);
            const lines = d.properties.name?.split(" ") || [];
            const lineHeightEm = 1.2;
            const offset = -((lines.length - 1) / 2) * lineHeightEm;

            lines.forEach((line, i) => {
              textEl.append("tspan")
                .attr("x", 0)
                .attr("dy", (i === 0 ? offset : lineHeightEm) + "em")
                .text(line);
            });
          });

      }

      render = () => {
        const showTerrain = document.getElementById("toggleTerrain").checked;
        const showSpawn = document.getElementById("toggleSpawn").checked;

        svg.select(".terrainImage").attr("visibility", showTerrain ? "visible" : "hidden");

        zoom.on("start", hideTooltip)

        const regionType = currentRegionType;
        svg.select(".mining").remove();
        svg.select(".names").remove();
        svg.select(".poi").remove();
        svg.select(".spawn").remove();
        const opacity = showTerrain || showSpawn ? 0.7 : 1.0;

        const selectedColors = getSelectedColors();
        renderRegions(regionType, opacity, selectedColors);

        const spawn = svg.append("g").attr("class", "spawn");
        spawn.attr("visibility", showSpawn ? "visible" : "hidden");
        const currentTransform = d3.zoomTransform(svg.node());
        spawn.attr("transform", currentTransform);

        Object.entries(allData.start_locations).forEach(([name, coords]) => {
          let px = coords[0] / mapWidth + 0.5;
          let py = 1.0 - (coords[1] / mapHeight + 0.5);
          if (northUp) {
            px = 1 - px;
            py = 1 - py;
          }
          const [x, y] = [width * px, height * py]

          spawn.append("circle")
            .attr("cx", x)
            .attr("cy", y)
            .attr("r", 5)
            .attr("fill", "red")
            .attr("stroke", "black")
            .attr("stroke-width", 1);

          spawn.append("text")
            .attr("x", x + 7)
            .attr("y", y - 7)
            .text(name)
            .style("font-size", "14px")
            .style("fill", "white")
            .style("stroke", "black")
            .style("stroke-width", "2px")
            .style("paint-order", "stroke")
        });

        const svgWidth = +svg.attr("width");
        const svgHeight = +svg.attr("height");
        svg.select(".icons").raise();
        const compass = svg.select(".compass");
        compass.raise();
        compass.attr("transform", `translate(${width - 30}, ${height - 40})`);
      }

      svg.call(zoom);

      updateRender = () => {
        colorFilter.selectAll("*").remove(); // clear filters
        const data = allData[currentRegionType].features;

        const uniqueColors = Array.from(new Set(data.map(f => f.properties.color_hex)))
          .filter(c => c); // remove undefined

        const color2Name = {};

        data.forEach(f => {
          if (f.properties.color_hex)
            color2Name[f.properties.color_hex] = f.properties.name;
        });

        // Add "All" checkbox for convenience
        colorFilter.append("label")
          .html(`<input type="checkbox" value="all"> All`)
          .style("margin-right", "10px")
          .style("display", "block")
          ;

        uniqueColors.forEach(color => {
          colorFilter.append("label")
            .html(`<input type="checkbox" value="${color}"> <span style="color:${color}">${color2Name[color]}</span>`)
            .style("display", "block")
            .style("margin-right", "10px");
        });
        for (const i in colorFilter.selectAll("input[type=checkbox]").nodes())
          if (selectedRegions.includes(parseInt(i)))
            colorFilter.selectAll("input[type=checkbox]").nodes()[i].checked = true;

        colorFilter.selectAll("input[type=checkbox]").on("change", function () {
          if (this.value === "all") {
            if (this.checked) {
              colorFilter.selectAll("input[type=checkbox]").property("checked", false);
              this.checked = true;
            }
          } else {
            if (this.checked) {
              colorFilter.select("input[value=all]").property("checked", false);
            }
            // If none checked, check "All"
            if (colorFilter.selectAll("input[type=checkbox]:checked").nodes().length === 0) {
              colorFilter.select("input[value=all]").property("checked", true);
            }
          }
          render();
        });

        render();
      }

      updateRender();
      addIcons()
    }

    d3.selectAll("#planetButtons button").on("click", function () {
      const planet = d3.select(this).attr("data-file");
      svg.call(zoom.transform, d3.zoomIdentity);
      selectedRegions = [0];
      loadMap(planet, currentRegionType);
    });

    d3.selectAll("#regionTypeButtons button").on("click", function () {
      selectedRegions = [0];
      currentRegionType = d3.select(this).attr("data-region");
      updateRender();
    });
    d3.select("#toggleTerrain").on("change", () => {render();});
    d3.select("#toggleSpawn").on("change", () => {render();});
    d3.select("#toggleNorth").on("change", () => {
      northUp = d3.select("#toggleNorth").property("checked");
      loadMap(currentPlanet, currentRegionType);
    });

    d3.select("#share").on("click", () => {
      getSettingsFromUI();
    });

  </script>
</body>

</html>
